// noinspection JSCheckFunctionSignatures

// region Variables
//region Selectors
let start = $('#start'); // Splash page
let editor = $('#editor'); // Editor page
let filter_template = $('#base-filter > div');
let affix_template = $('#base-affix');
let close_template = $('#base-unique-close');
let move_template = $('#base-unique-move');
let blank_filter = $('#blank div');
let input = document.createElement('input');
//endregion

//region Constants
//region For the Editor
const original_editor = editor.clone();
const editor_layout = [
    {slot: 'helm', filters: null,},
    {slot: 'main_hand', filters: null,},
    {},

    {slot: 'chest', filters: null,},
    {slot: 'off_hand', filters: null,},
    {slot: 'amulet', filters: null,},

    {slot: 'gloves', filters: null,},
    {},
    {slot: 'ring', filters: null,},

    {slot: 'pants', filters: null,},
    {slot: 'left_hand', filters: null,},
    {slot: 'other_ring', filters: null,},

    {slot: 'boots', filters: null,},
    {slot: 'right_hand', filters: null,},
];
const one_handed_weapons = [
    'Axe',
    'Dagger',
    'Mace',
    'Scythe',
    'Sword',
    'Wand',
];
const off_hand_weapons = [
    'Focus',
    'Shield',
    'Totem',
];
const two_handed_weapons = [
    'Axe2H',
    'Bow',
    'Crossbow2H',
    'Mace2H',
    'Polearm',
    'Scythe2H',
    'Staff',
    'Sword2H',
];
const implicit_affixes = {
    'boots': [
        'evade_grants_movement_speed_for_second',
        'attacks_reduce_evades_cooldown_by_seconds',
        'maximum_evade_charges',
    ],
    // 'Inherent' in D4LF
    // https://d4builds.gg/database/gear-affixes/
}
const symbols = {
    'more': '‚ùØ', // &#10095;
    'less': '‚ùÆ', // &#10094;
    'one-of': '‚Ä¢', // &#8226;
    'required': '‚úî', // &#10004;
    'greater': 'üû∫', // &#128954;
};
const comparison = {
    'larger': symbols['more'],
    'smaller': symbols['less'],
};
const affix_states = {
    'one-of': 'one-of',
    'required': 'required',
    'greater': 'greater',
};
const affix_state = {
    'one-of': symbols['one-of'],
    'required': symbols['required'],
    'greater': symbols['greater'],
};
const new_filter = true;
const existing_filter = false;
const synonyms = {
    'helm': 'head',
    'chest': 'chest armor',
    'amulet': 'amulet',
    'gloves': 'gloves',
    'ring': 'ring',
    'pants': 'pants',
    'other_ring': 'ring',
    'boots': 'boots',
};
//endregion

//region For unique-to-slot mapping
const mapping_label = 'd4lf-editor_uniques_mapping';
const mapping_label_separator = '------------';
const mapping_separator = '--';
const mapping_key_separator = ':';
//endregion

//region For abbreviating affixes
const affix_abbreviations = {
    'evade_grants_movement_speed_for_second': 'evade gives speed',
    'attacks_reduce_evades_cooldown_by_seconds': 'attacks reduce evade cd',
    'maximum_evade_charges': 'max evades',
    'cooldown_reduction': 'cdr',
    'resistance_to_all_elements': 'resist all',
    'maximum_life': 'max hp',
    'critical_strike_chance': 'crit chance',
    'critical_strike_damage': 'crit damage',
    'attack_speed': 'atk speed',
    'movement_speed': 'move speed',
}
const affix_dynamic_abbreviations = {
    'lucky_hit_': [
        ['lucky_hit', 'lucky hit'],
        ['critical_strikes_have', '(crit)'],
        ['_up_to_a_chance_to', ':'],
        ['_for_seconds', ''],
    ],
    'chance_for_': [
        ['chance_for', 'cast:'],
        ['to_cast_twice', ''], // x2, but have to handle it with custom logic,
        ['a_second', ''], // x2, but have to handle it with custom logic
        ['when_cast', ''],
    ],
    'resource_generation_w': [
        ['resource_generation', 'extra gen:'],
    ],
    'critical_strike_chance_against_': [
        ['critical_strike_chance_against', 'crit vs:'],
    ],
};
//endregion

//region For the Editor itself
const version = '0.0.3(season5)';
const supported_d4lf = 'v5.7.5';
const yaml_header_comment = ''
    + '# Generated by D4LF-editor version ' + version + '\n'
    + '# For D4LF version ' + supported_d4lf + '\n';
// Writing the version numbers to the web page
$('.version').text(version);
$('.supported-d4lf').text(supported_d4lf);
//endregion
//endregion

//region Working Data
let editor_source = null;
let editor_data = editor_layout; // Editor working data
let filter = {}; // Loaded filter data
let filter_part_template = {
    'slot': '',
    'item_type': null,
    'unique': false,
    'unique_aspect': null,
    'minPower': 0,
    'affixes': {
        'required': [], // list of required_affix_base
        'pool': {
            'list': [], // list of affix_base
            'greater_required': 0,
            'total_required': 0,
        },
        'implicit': [],
    },
};
let mapping_template_body = {
    "minPower": 9999,
    "itemType": "elixir",
    "affixPool": [
        {
            "count": [
                {
                    "name": "attack_speed",
                    "comparison": "larger",
                    "value": 999
                },
            ],
            "minCount": 99,
            "minGreaterAffixCount": 99
        }
    ]
};
let found_imported_comments = '';
let file = null; // Uploaded file
let file_name = ''; // Uploaded file name
let reader = new FileReader(); // File reader
//endregion
//endregion

////////////////////////////////////////////////////////////////////////////////////
//region Editor data
////////////////////////////////////////////////////////////////////////////////////

// List of all affixes
$.getJSON(
    'https://d4lf-editor.zbee.codes/json/affixes.json',
    function (data) {
        $.each(data, function (key, value) {
            $('.affix-list').append(
                '<option data-key="' + key + '" data-value="' + value + '">' +
                value +
                '</option>'
            );
        });
    }
);

// List of just weapons
$.getJSON(
    'https://d4lf-editor.zbee.codes/json/item_types.json',
    function (data) {
        $.each(data, function (key, value) {
            // noinspection JSUnresolvedReference
            let key_check = key.toLowerCase();
            if (
                key_check.includes('axe')
                || key_check.includes('bow')
                || key_check.includes('dagger')
                || key_check.includes('focus')
                || key_check.includes('mace')
                || key_check.includes('totem')
                || key_check.includes('polearm')
                || key_check.includes('scythe')
                || key_check.includes('shield')
                || key_check.includes('staff')
                || key_check.includes('sword')
                || key_check.includes('wand')
            ) {
                $('.item-list').append(
                    '<option data-key="' + key + '" data-value="' + value + '">' +
                    capitalize(value) +
                    '</option>'
                );
            }
        });
    }
);

// List of all uniques
$.getJSON(
    'https://d4lf-editor.zbee.codes/json/uniques.json',
    function (data) {
        $.each(data, function (key, value) {
            // Filter out some of the dud values
            if (key.toString().includes('(')
                || key.toString().includes('[')
                || key.toString().includes('boost')
                || value['desc'].toLowerCase().includes('test item')
                || value['desc'].toLowerCase().includes('tbd')) {
                return;
            }

            $('.unique-list').append(
                '<option data-key="' + key + '" data-value="' + value['desc'] + '">' +
                capitalize(key) +
                '</option>'
            );
        });
    }
);
//endregion

////////////////////////////////////////////////////////////////////////////////////
//region Editor Utilities
////////////////////////////////////////////////////////////////////////////////////

// https://stackoverflow.com/a/1026087/1843510
function capitalize(string) {
    string = string.replace(/_/g, ' ');
    return string.charAt(0).toUpperCase() + string.slice(1);
}

// To get to the editor page, while loading data or just from scratch
function to_editor(filter_selection) {
    // Fail out
    if (filter_selection !== new_filter
        && filter_selection !== existing_filter) {
        return;
    }

    // Open a file dialog to choose a filter
    if (filter_selection === existing_filter) {
        // The .yaml file dialog
        input.type = 'file';
        input.accept = '.yaml';
        input.click();
        // Triggers input.onchange below, then reader.onload
    } else {
        editor_source = new_filter;
        show_editor();
    }
}

// Load the given filter file
input.onchange = e => {
    file = e.target.files[0];
    file_name = file.name;
    reader.readAsText(file, 'UTF-8');
}

// Actually build and show the editor page
function show_editor() {
    // Clear the page
    start.hide();

    // Show the editor
    $('body').css('maxWidth', '70em');
    editor.show();
    // Build the editor
    build_editor();
}

// Build the editor HTML from template code (#base-filter)
function build_editor() {
    editor.html(original_editor.html());
    console.debug(editor_data);

    // Iterate over equipment slots
    editor_data.forEach(function (layout_item) {
        // Skip slots labelled 'unique'
        if (layout_item.slot === 'unique') {
            return;
        }
        // Fill blank slots
        if (jQuery.isEmptyObject(layout_item)) {
            (blank_filter.clone()).insertBefore('#controls');
            return;
        }

        // Build the editor slots
        // Copy the template
        let new_filter = filter_template.clone();
        // Fill basic data, if it's a new filter
        if (editor_source === new_filter || layout_item.filters === null) {
            // Fill the ID into the template
            new_filter.attr('id', layout_item.slot);
            new_filter.find('u').text(capitalize(layout_item.slot));

            // Show Item-Type selector for weapons
            if (layout_item.slot.includes('hand')) {
                new_filter.find('.select-item-type').show();
            }
        }
        // Fill the filter data, if it's an existing filter
        else if (editor_source === existing_filter) {
            // Fill the ID into the template
            new_filter.attr('id', layout_item.slot);
            new_filter.find('u').text(capitalize(layout_item.slot));

            // Fill the minPower
            if (layout_item.filters.hasOwnProperty('minPower')) {
                new_filter
                    .find('[data-key="minPower"] input')
                    .val(layout_item.filters['minPower']);
            }

            // Fill the itemType
            if (layout_item.filters.hasOwnProperty('itemType')) {
                let item_type = layout_item.filters['itemType'];
                if (Array.isArray(item_type)) {
                    item_type = item_type[0];
                }
                // Set the item type
                new_filter
                    .find('.item-list option[data-key="' + item_type + '"]')
                    .attr('selected', '');
                // Unselect the default option
                new_filter.find('.item-list option').first().removeAttr('selected');
                if (layout_item.slot.includes('hand')) {
                    // Hide unique selection if item type is selected
                    new_filter.find('.unique-selection').hide();
                }
            }

            // Fill the Unique
            if (layout_item.filters.hasOwnProperty('aspect')) {
                let unique = layout_item.filters['aspect'];
                if (Array.isArray(unique)) {
                    unique = unique[0];
                }
                if (typeof unique === 'object') {
                    unique = unique['name'];
                }
                // Set the unique
                new_filter
                    .find('.unique-list option[data-key="' + unique + '"]')
                    .attr('selected', '');
                // Unselect the default option
                new_filter.find('.unique-list option')
                          .first()
                          .removeAttr('selected');
                // Show the unique roll if unique is selected
                new_filter.find('.unique-roll').show();
                // Hide the item type selection if unique is selected
                new_filter.find('.select-item-type').hide();
            }

            // Fill the Unique aspect roll
            if (layout_item.filters.hasOwnProperty('aspect')) {
                let roll = layout_item.filters['aspect'];
                if (Array.isArray(roll)) {
                    let value = '0';
                    if (roll.length >= 2) {
                        value = roll[1];
                    }
                    let compare = ['larger', comparison['larger']];
                    if (roll.length >= 3) {
                        compare = [roll[2], comparison[roll[2]]];
                    }
                    new_filter.find('.unique-roll input').val(value);
                    new_filter.find('.unique-roll .comparison').html(compare[1]);
                    new_filter.find('.unique-roll .comparison').data(
                        'current',
                        compare[0]
                    );
                }
            }

            // Fill minGreaterAffixCount
            if (layout_item.filters.hasOwnProperty('affixPool')
                && layout_item.filters['affixPool'][0].hasOwnProperty(
                    'minGreaterAffixCount')) {
                new_filter
                    .find('[data-key="minGreaterAffixCount"] input')
                    .val(layout_item.filters['affixPool'][0]['minGreaterAffixCount']);
            }
            // Again, for uniques
            if (layout_item.filters.hasOwnProperty('minGreaterAffixCount')) {
                new_filter
                    .find('[data-key="minGreaterAffixCount"] input')
                    .val(layout_item.filters['minGreaterAffixCount']);
            }

            // Fill minCount
            if (layout_item.filters.hasOwnProperty('minCount')) {
                new_filter
                    .find('[data-key="minCount"] input')
                    .val(layout_item.filters['minCount']);
            }

            // todo: this should be a loop over `layout_item.filters['affixPool']`,
            //  to account for multiple pools (e.g. with different minCount)
            // Fill affixes
            if (layout_item.filters.hasOwnProperty('affixPool')
                && layout_item.filters['affixPool'][0].hasOwnProperty('count')
                && layout_item.filters['affixPool'][0]['count'].length > 0) {
                // Foreach affix in the affixPool.count
                for (let i = 0; i < layout_item.filters['affixPool'][0]['count'].length; i++) {
                    let affix = layout_item.filters['affixPool'][0]['count'][i];
                    // noinspection DuplicatedCode
                    let key = '';
                    let value = 0;
                    let compare = 'larger';

                    // Parse different layouts of affixes
                    if (Array.isArray(affix)) {
                        key = affix[0];
                        if (affix.length >= 2) {
                            value = affix[1];
                        }
                        if (affix.length >= 3) {
                            compare = affix[2];
                        }
                    } else if (typeof affix === 'object') {
                        key = affix['name'];
                        if (affix.hasOwnProperty('value')) {
                            value = affix['value'];
                        }
                        if (affix.hasOwnProperty('comparison')) {
                            compare = affix['comparison'];
                        }
                    } else if (typeof affix === 'string') {
                        key = affix;
                    }

                    // Add the affix to the affix list
                    add_affix(
                        new_filter,
                        key,
                        compare,
                        value
                    );
                }
            }
            // Again, for uniques
            if (layout_item.filters.hasOwnProperty('affix')
                && layout_item.filters['affix'].length > 0) {
                // Foreach affix in the affixPool.count
                for (let i = 0; i < layout_item.filters['affix'].length; i++) {
                    let affix = layout_item.filters['affix'][i];
                    // noinspection DuplicatedCode
                    let key = '';
                    let value = 0;
                    let compare = 'larger';

                    // Parse different layouts of affixes
                    if (Array.isArray(affix)) {
                        key = affix[0];
                        if (affix.length >= 2) {
                            value = affix[1];
                        }
                        if (affix.length >= 3) {
                            compare = affix[2];
                        }
                    } else if (typeof affix === 'object') {
                        key = affix['name'];
                        if (affix.hasOwnProperty('value')) {
                            value = affix['value'];
                        }
                        if (affix.hasOwnProperty('comparison')) {
                            compare = affix['comparison'];
                        }
                    } else if (typeof affix === 'string') {
                        key = affix;
                    }

                    // Add the affix to the affix list
                    add_affix(
                        new_filter,
                        key,
                        compare,
                        value
                    );
                }
            }

            // Fill inherent affixes
            if (layout_item.filters.hasOwnProperty('inherentPool')
                && layout_item.filters['inherentPool'][0].hasOwnProperty('count')
                && layout_item.filters['inherentPool'][0]['count'].length > 0) {
                // Foreach affix in the affixPool.count
                for (let i = 0; i < layout_item.filters['inherentPool'][0]['count'].length; i++) {
                    let affix = layout_item.filters['inherentPool'][0]['count'][i];
                    // noinspection DuplicatedCode
                    let key = '';
                    let value = 0;
                    let compare = 'larger';

                    // Parse different layouts of affixes
                    if (Array.isArray(affix)) {
                        key = affix[0];
                        if (affix.length >= 2) {
                            value = affix[1];
                        }
                        if (affix.length >= 3) {
                            compare = affix[2];
                        }
                    } else if (typeof affix === 'object') {
                        key = affix['name'];
                        if (affix.hasOwnProperty('value')) {
                            value = affix['value'];
                        }
                        if (affix.hasOwnProperty('comparison')) {
                            compare = affix['comparison'];
                        }
                    } else if (typeof affix === 'string') {
                        key = affix;
                    }

                    // Add the affix to the affix list
                    add_affix(
                        new_filter,
                        key,
                        compare,
                        value
                    );
                }
            }
        }

        // Place the editor slot
        new_filter.insertBefore('#controls');
    })

    // Iterate over uniques
    editor_data.forEach(function (unique) {
        // Skip non-uniques
        if (unique.slot !== 'unique') {
            return;
        }

        // Add the unique
        add_unique(unique.filters);
    });
}

// Return to the home page
function to_home() {
    filter = {};
    editor.html(original_editor.html());

    start.show();
    editor.hide();
    $('body').css('maxWidth', '38em');
}

// Check if affix is one that is dynamically abbreviated, and abbreviate it if so
function abbreviate_affix(affix_key) {
    // Abbreviate the affix if the key is in the list or if it's too long
    if (affix_abbreviations.hasOwnProperty(affix_key)) {
        return affix_abbreviations[affix_key];
    }

    // If key starts with a dynamic abbreviation, replace each segment of it
    for (const [abbreviation, replacements]
        of Object.entries(affix_dynamic_abbreviations)) {
        if (affix_key.startsWith(abbreviation)) {
            for (const [segment, replacement] of replacements) {
                affix_key = affix_key.replace(segment, replacement);
            }
        }
    }

    // Replace underscores with spaces
    affix_key = affix_key.replace(/_/g, ' ');

    // Abbreviate the affix if it's too long
    if (affix_key.length > 35) {
        affix_key = affix_key.substring(0, 32) + '...';
    }

    return affix_key;
}

// Build list of affixes in the element
function build_affixes(element) {
    let affixes = element.find('.affixes').children();
    let affix_list = [];

    // Iterate over the affixes
    affixes.each(function () {
        let affix = $(this).data('key');
        affix_list.push(affix);
    });

    return affix_list;
}

//endregion

////////////////////////////////////////////////////////////////////////////////////
//region Editor UX
////////////////////////////////////////////////////////////////////////////////////

// Alternate the comparison operator for an aspect or affix
function change_comparison(element) {
    let current_comparison = element.data('current');
    if (current_comparison === 'larger') {
        element.data('current', 'smaller');
        element.html(comparison['smaller']);
    } else {
        element.data('current', 'larger');
        element.html(comparison['larger']);
    }
}

// Alternate the state of an affix
// one-of -> required -> greater -> one-of
function change_affix_state(element) {
    let current_state = element.data('current');
    // one-of -> required
    if (current_state === 'one-of') {
        element.data('current', 'required');
        element.html(affix_state['required']);
        element.attr(
            'title',
            "This affix must be present"
        );
    }
    // required -> greater
    else if (current_state === 'required') {
        element.data('current', 'greater');
        element.html(affix_state['greater']);
        element.attr(
            'title',
            "This affix must be present and be a greater affix"
        );
    }
    // greater -> one-of
    else if (current_state === 'greater') {
        element.data('current', 'one-of');
        element.html(affix_state['one-of']);
        element.attr(
            'title',
            "Any of these affixes, according to the Minimum count, can be present"
        );
    }

}

// Show both Item-Type and Unique selectors without values, with values: only
// show one or the other
function toggle_unique_or_item(element) {
    let value = element.children('option:selected').val();

    // Show both
    if (value === '') {
        $('.select-item-type').fadeIn("slow");
        $('.unique-selection').fadeIn("slow");
    }
    // Hide the other
    else {
        let parent_class = element.parent().attr('class');

        if (parent_class === 'select-item-type') {
            element.parent().parent().find('.unique-selection').hide();
        } else {
            element.parent().parent().find('.select-item-type').hide();
        }
    }
}

// Show the Unique sub-option to control the Unique's aspect only when a Unique
// is selected
function toggle_unique_aspect(element) {
    let value = element.children('option:selected').val();

    // Show the Unique sub-option for the Unique aspect
    if (value === '') {
        element.parent().parent().find('.unique-roll').hide();
    }
    // Hide the Unique sub-option
    else {
        element.parent().parent().find('.unique-roll').fadeIn("slow");
    }
}

// Add an affix to the affix list
function add_affix(
    element,
    affix_key = null,
    affix_compare = null,
    affix_compare_value = null
) {
    let affix_value;
    // Get the affix key and value
    if (affix_key !== null) {
        // From the gear slot element
        element = element.find('.affix-list').parent();
        let affixes = element.find('select');
        affix_value = affixes.find('option[data-key="' + affix_key + '"]').data(
            'value');
    } else {
        // From the button
        let affix = element.find('select').children('option:selected');
        affix_key = affix.data('key');
        affix_value = affix.data('value');
    }

    // Bail if affix already in list
    let current_affixes = build_affixes(element.parent());
    if (current_affixes.includes(affix_key)) {
        return;
    }

    // Bail if no value
    if (affix_value === '') {
        return;
    }

    // Add the affix to .affixes, based off of #base-affix
    let new_affix = affix_template.clone();
    new_affix.show();
    new_affix.fadeOut(0);

    // Set the affix key and value
    let affix_text = new_affix.find('p');
    affix_text.text(affix_value);
    new_affix.data('key', affix_key);

    // Abbreviate the affix if it's too long, or if it's on the list with shorter names
    let abbr = abbreviate_affix(affix_key);
    let no__affix_key = affix_key.replace(/_/g, ' ');
    if (abbr !== no__affix_key) {
        affix_text.html(
            '<abbr title="' + affix_value + '">'
            + abbr
            + '</abbr>'
        );
    }

    // Add in the comparison and value, if they were passed
    if (affix_compare !== null) {
        let compare = new_affix.find('.comparison');
        compare.html(comparison[affix_compare]);
        compare.data('current', affix_compare);
    }
    if (affix_compare_value !== null) {
        new_affix.find('input').val(affix_compare_value);
    }

    // Add the affix to the affix list
    element.parent().find('.affixes').append(new_affix);
    new_affix.fadeIn("slow");
}

// Add a new filter, for uniques
function add_unique(filter_override = null) {
    // Build a new filter element from the template
    let new_unique = filter_template.clone();
    new_unique.css('overflow', 'visible');
    new_unique.find('div:first').css('position', 'relative');

    // Add an id with a unique number, that isn't already in use
    let random_id = Math.floor(Math.random() * 10000);
    while ($('#unique-' + random_id).length) {
        random_id = Math.floor(Math.random() * 10000);
    }
    new_unique.attr('id', 'unique-' + random_id);

    // Add a close button to the new unique from the template
    let close_button = close_template.clone();
    close_button.show();
    close_button.insertBefore(new_unique.find('u'));

    // Add a move button to the new unique from the template
    let move_button = move_template.clone();
    move_button.show();
    move_button.insertAfter(new_unique.find('u'));

    // Set up the template for uniques
    new_unique.find('u').text('Unique');
    new_unique.find('.select-item-type').hide();
    new_unique.find('.unique-roll').show();
    new_unique.show();
    new_unique.fadeOut(0);
    // Remove the empty unique option
    new_unique.find('.unique-selection select').children().first().remove();
    // Remove the ? from the unique label
    new_unique.find('.unique-selection small').text('Unique');

    // Fill from an existing filter
    if (filter_override !== null) {
        // Fill the minPower
        if (filter_override.hasOwnProperty('minPower')) {
            new_unique
                .find('[data-key="minPower"] input')
                .val(filter_override['minPower']);
        }

        // Fill the Unique
        if (filter_override.hasOwnProperty('aspect')) {
            let unique = filter_override['aspect'];
            if (Array.isArray(unique)) {
                unique = unique[0];
            }
            if (typeof unique === 'object') {
                unique = unique['name'];
            }
            // Set the unique
            new_unique
                .find('.unique-list option[data-key="' + unique + '"]')
                .attr('selected', '');
            // Unselect the default option
            new_unique.find('.unique-list option')
                      .first()
                      .removeAttr('selected');
            // Show the unique roll if unique is selected
            new_unique.find('.unique-roll').show();
            // Hide the item type selection if unique is selected
            new_unique.find('.select-item-type').hide();
        }

        // Fill the Unique aspect roll
        if (filter_override.hasOwnProperty('aspect')) {
            let roll = filter_override['aspect'];
            if (Array.isArray(roll)) {
                let value = '0';
                if (roll.length >= 2) {
                    value = roll[1];
                }
                let compare = ['larger', comparison['larger']];
                if (roll.length >= 3) {
                    compare = [roll[2], comparison[roll[2]]];
                }
                new_unique.find('.unique-roll input').val(value);
                new_unique.find('.unique-roll .comparison').html(compare[1]);
                new_unique.find('.unique-roll .comparison').data(
                    'current',
                    compare[0]
                );
            }
        }

        // Fill minGreaterAffixCount
        if (filter_override.hasOwnProperty('minGreaterAffixCount')) {
            new_unique
                .find('[data-key="minGreaterAffixCount"] input')
                .val(filter_override['minGreaterAffixCount']);
        }

        // Fill minCount
        if (filter_override.hasOwnProperty('minCount')) {
            new_filter
                .find('[data-key="minCount"] input')
                .val(filter_override['minCount']);
        }

        // Fill affixes
        if (filter_override.hasOwnProperty('affix')
            && filter_override['affix'].length > 0) {
            // Foreach affix in the affixPool.count
            for (let i = 0; i < filter_override['affix'].length; i++) {
                let affix = filter_override['affix'][i];
                // noinspection DuplicatedCode
                let key = '';
                let value = 0;
                let compare = 'larger';

                // Parse different layouts of affixes
                if (Array.isArray(affix)) {
                    key = affix[0];
                    if (affix.length >= 2) {
                        value = affix[1];
                    }
                    if (affix.length >= 3) {
                        compare = affix[2];
                    }
                } else if (typeof affix === 'object') {
                    key = affix['name'];
                    if (affix.hasOwnProperty('value')) {
                        value = affix['value'];
                    }
                    if (affix.hasOwnProperty('comparison')) {
                        compare = affix['comparison'];
                    }
                } else if (typeof affix === 'string') {
                    key = affix;
                }

                // Add the affix to the affix list
                add_affix(
                    new_unique,
                    key,
                    compare,
                    value
                );
            }
        }

        // Fill inherent affixes
        if (filter_override.hasOwnProperty('inherentPool')
            && filter_override['inherentPool'][0].hasOwnProperty('count')
            && filter_override['inherentPool'][0]['count'].length > 0) {
            // Foreach affix in the affixPool.count
            for (let i = 0; i < filter_override['inherentPool'][0]['count'].length; i++) {
                let affix = filter_override['inherentPool'][0]['count'][i];
                // noinspection DuplicatedCode
                let key = '';
                let value = 0;
                let compare = 'larger';

                // Parse different layouts of affixes
                if (Array.isArray(affix)) {
                    key = affix[0];
                    if (affix.length >= 2) {
                        value = affix[1];
                    }
                    if (affix.length >= 3) {
                        compare = affix[2];
                    }
                } else if (typeof affix === 'object') {
                    key = affix['name'];
                    if (affix.hasOwnProperty('value')) {
                        value = affix['value'];
                    }
                    if (affix.hasOwnProperty('comparison')) {
                        compare = affix['comparison'];
                    }
                } else if (typeof affix === 'string') {
                    key = affix;
                }

                // Add the affix to the affix list
                add_affix(
                    new_unique,
                    key,
                    compare,
                    value
                );
            }
        }
    }

    // Add the unique to the unique list
    new_unique.insertAfter('#uniques');
    new_unique.fadeIn(800);
}

// Move a unique to a gear slot, deleting the unique
function move_unique(element) {
    // Check the target to update with the Unique's data
    let target = element.parent().parent().find('select')
                        .children('option:selected').val();
    // Parse the unique
    let unique = element.parent().parent().parent().parent();
    let parsed_unique = parse_element(unique);
    // Move the unique to the target
    update_element($('#filters').find('#' + target), parsed_unique);
    // Remove the unique
    unique.remove();
}

//endregion

////////////////////////////////////////////////////////////////////////////////////
//region Loading Utilities
////////////////////////////////////////////////////////////////////////////////////

// todo: build_unique_slot_mapping()
function build_unique_slot_mapping(filter) {
    let mapping = [];

    // Foreach filter in filter
    for (let i = 0; i < filter.length; i++) {
        let filter_item = filter[i];
        let slot = filter_item['slot'];
        let unique = filter_item['unique'];
        let unique_aspect = filter_item['unique_aspect'];

        // Skip if no unique
        if (!unique) {
            continue;
        }
        // Skip if slot is unique
        if (slot === 'unique') {
            continue;
        }

        // Add the unique to the mapping
        mapping.push(
            slot + mapping_key_separator + unique_aspect['name']
        );
    }

    return mapping.join(mapping_separator);
}

// Check for an existing unique-to-slot mapping, and parse it if it exists
function read_unique_slot_mapping(filter) {
    let uniques = filter['Uniques'];
    let affixes = filter['Affixes'];

    // Build simple list of aspect names of uniques
    let unique_aspects = [];
    for (let i = 0; i < uniques.length; i++) {
        let unique = uniques[i];
        let aspect = unique['aspect'];
        if (Array.isArray(aspect)) {
            aspect = aspect[0];
        }
        if (typeof aspect === 'object') {
            aspect = aspect['name'];
        }
        unique_aspects.push(aspect);
    }

    // Foreach array element, check if it's a unique-to-slot mapping
    for (let i = 0; i < affixes.length; i++) {
        let affix = affixes[i];
        // Get the one key in the object
        let key = Object.keys(affix)[0];
        // Check if the key is a unique-to-slot mapping
        if (key.startsWith(mapping_label)) {
            // Get just the mapping data
            let mapping = key.split(mapping_label_separator)[1];
            // Split maps into individual mappings
            let mappings = mapping.split(mapping_separator);

            // Build a mapping object
            let mapping_data = {};
            for (let j = 0; j < mappings.length; j++) {
                // Split the mapping into key and value
                let mapping_parts = mappings[j].split(mapping_key_separator);
                // Check that the mapping  data is valid
                if (mapping_parts.length !== 2) {
                    continue;
                }
                // Check that there is a unique for the mapping
                if (!unique_aspects.includes(mapping_parts[1])) {
                    continue;
                }

                // Add the mapping to the mapping object
                mapping_data[mapping_parts[0]] = mapping_parts[1];
            }

            // Check that the mapping object has data
            if (jQuery.isEmptyObject(mapping_data)) {
                continue;
            }

            // Return the mapping data
            return mapping_data;
        }
    }

    return false;
}

// Check for weapon filters, and fit them to all four weapon slots
function parse_weapons(unique_mapping) {
    //region Setup
    let weapons = {
        'main_hand': null,
        'off_hand': null,
        'left_hand': null,
        'right_hand': null,
    }
    let found_weapon_types = [];

    let number_1H_weapons = 0;
    let number_2H_weapons = 0;
    let number_off_hand_weapons = 0;

    // Find all weapon filters
    for (let i = 0; i < filter['Affixes'].length; i++) {
        let filter_item = filter['Affixes'][i];
        let name = Object.keys(filter_item)[0];
        let item_type = filter_item[name]['itemType'];

        // Don't support multiple item types in a single filter
        // Make item_type the first type if it's an array of types
        if (Array.isArray(item_type)) {
            item_type = item_type[0];
        }

        // Record the weapon type
        if (one_handed_weapons.includes(item_type)) {
            number_1H_weapons++;
            found_weapon_types.push({'name': name, 'type': item_type});
        } else if (two_handed_weapons.includes(item_type)) {
            number_2H_weapons++;
            found_weapon_types.push({'name': name, 'type': item_type});
        } else if (off_hand_weapons.includes(item_type)) {
            number_off_hand_weapons++;
            found_weapon_types.push({'name': name, 'type': item_type});
        }
    }
    //endregion

    //region Unique Assignments
    // Assign unique mappings to weapons, if they exist, then make all the other
    // weapon assignments haphazardly since it came out of the editor
    if (unique_mapping !== false) {
        // Assign unique mappings to weapons
        for (const [key, value] of Object.entries(unique_mapping)) {
            if (weapons.hasOwnProperty(key)) {
                weapons[key] = [value];
            }
        }
        // Assign found weapons - their names must be free if this was through the
        // filter already
        for (let i = 0; i < found_weapon_types.length; i++) {
            let weapon = found_weapon_types[i];
            weapons[weapon['name']] = weapon['name'];
        }

        return weapons;
    }
    //endregion

    /*
    console.debug(
        'found:', found_weapon_types,
        '1H:', number_1H_weapons,
        '2H:', number_2H_weapons,
        'OH:', number_off_hand_weapons,
    );
    */

    //region Rule Assignments
    // Assign weapons to slots
    // Assign 2H weapons to main-hand and off-hand, if they exist
    if (number_2H_weapons > 0) {
        for (let i = 0; i < found_weapon_types.length; i++) {
            let weapon = found_weapon_types[i];
            if (two_handed_weapons.includes(weapon['type'])) {
                if (weapons['main_hand'] === null) {
                    weapons['main_hand'] = weapon['name'];
                } else {
                    if (weapons['off_hand'] === null) {
                        weapons['off_hand'] = weapon['name'];
                    }
                }
            }
        }
    }
    // Assign off-hand weapons to off-hand/right-hand
    if (number_off_hand_weapons > 0) {
        if (number_2H_weapons === 0 && weapons['off_hand'] === null) {
            for (let i = 0; i < found_weapon_types.length; i++) {
                let weapon = found_weapon_types[i];
                if (off_hand_weapons.includes(weapon['type'])) {
                    weapons['off_hand'] = weapon['name'];
                }
            }
        } else {
            for (let i = 0; i < found_weapon_types.length; i++) {
                let weapon = found_weapon_types[i];
                if (off_hand_weapons.includes(weapon['type'])) {
                    weapons['right_hand'] = weapon['name'];
                }
            }
        }
    }
    // Assign 1H weapons to main-hand/left-hand (and off-hand/right-hand, if
    // there's still more, and each is empty)
    if (number_1H_weapons > 0) {
        for (let i = 0; i < found_weapon_types.length; i++) {
            let weapon = found_weapon_types[i];
            if (one_handed_weapons.includes(weapon['type'])) {
                // noinspection DuplicatedCode
                if (weapons['main_hand'] === null) {
                    weapons['main_hand'] = weapon['name'];
                } else {
                    if (weapons['off_hand'] === null) {
                        weapons['off_hand'] = weapon['name'];
                    } else {
                        if (weapons['left_hand'] === null) {
                            weapons['left_hand'] = weapon['name'];
                        } else {
                            if (weapons['right_hand'] === null) {
                                weapons['right_hand'] = weapon['name'];
                            }
                        }
                    }
                }
            }
        }
    }
    // Try to assign any weapons that are left over and are not already assigned
    for (let i = 0; i < found_weapon_types.length; i++) {
        let weapon = found_weapon_types[i];

        // Check that weapon name is not already assigned
        if (Object.values(weapons).includes(weapon['name'])) {
            continue;
        }

        // noinspection DuplicatedCode
        if (weapons['main_hand'] === null) {
            weapons['main_hand'] = weapon['name'];
        } else {
            if (weapons['off_hand'] === null) {
                weapons['off_hand'] = weapon['name'];
            } else {
                if (weapons['left_hand'] === null) {
                    weapons['left_hand'] = weapon['name'];
                } else {
                    if (weapons['right_hand'] === null) {
                        weapons['right_hand'] = weapon['name'];
                    }
                }
            }
        }
    }
    //endregion

    // Return weapons object
    //console.debug(weapons);
    return weapons;
}

// Reduce the complexity of a query for searching (and possible results)
function query_cleaner(query) {
    // Leave nulls alone
    if (query === null) {
        return null;
    }
    // If query is an array, select the first element
    if (Array.isArray(query)) {
        query = query[0];
    }

    query = query.toLowerCase();
    query = query.replace(/_/g, '');
    query = query.replace(/-/g, '');
    query = query.replace(/ /g, '');
    return query;
}

// Check if there is a synonym for the given string
function has_synonym(query) {
    query = query_cleaner(query);
    return synonyms.hasOwnProperty(query);
}

// Get the synonym for the given string
function get_synonym(query) {
    query = query_cleaner(query);
    return synonyms[query];
}

// Get the synonym for the given string, if it has one
function get_synonym_if_has(query) {
    return has_synonym(query) ? get_synonym(query) : query;
}

// Search for a filter in the given parsed filter file, by key
function search_filter_by(key = null, item_type = null, first_search = true) {
    // Bail on bad queries
    if (key === null && item_type === null) {
        return null;
    }
    if (key === '' || item_type === '') {
        return null;
    }

    // Simplify queries
    key = query_cleaner(key);
    item_type = query_cleaner(item_type);

    //region Key Searching
    if (key !== null) {
        // Search for the key in the Affixes
        for (let i = 0; i < filter['Affixes'].length; i++) {
            let filter_item = filter['Affixes'][i];
            // use query_cleaner on all keys
            let filter_key = query_cleaner(Object.keys(filter_item)[0]);

            if (filter_key === key) {
                //console.debug('search result (A): ', filter_item[key]);
                return filter_item[key];
            }
        }

        // Search for the key in the Uniques
        for (let i = 0; i < filter['Uniques'].length; i++) {
            let filter_item = filter['Uniques'][i];
            if (Array.isArray(filter_item['aspect'])) {
                if (query_cleaner(filter_item['aspect'][0]) === key) {
                    //console.debug('search result ([U]): ', filter_item);
                    return filter_item;
                }
            }
            else if (typeof input === 'object') {
                if (query_cleaner(filter_item['aspect']['name']) === key) {
                    //console.debug('search result ([U]): ', filter_item);
                    return filter_item;
                }
            }
            else {
                if (query_cleaner(filter_item['aspect']) === key) {
                    //console.debug('search result (U): ', filter_item);
                    return filter_item;
                }
            }
        }
    }
    //endregion
    //region Item-Type Searching
    if (item_type !== null) {
        // Search for the item_type in the Affixes
        for (let i = 0; i < filter['Affixes'].length; i++) {
            let filter_item = filter['Affixes'][i];
            filter_item = filter_item[Object.keys(filter_item)[0]];
            let filter_item_type = query_cleaner(filter_item['itemType']);
            if (filter_item_type === item_type) {
                //console.debug('search result (I): ', filter_item);
                return filter_item;
            }
        }
    }
    //endregion

    // If key has a synonym, search for that
    if (has_synonym(key) && first_search) {
        return search_filter_by(get_synonym(key), null, false);
    }
    // If item_type has a synonym, search for that
    if (has_synonym(item_type) && first_search) {
        return search_filter_by(null, get_synonym(item_type), false);
    }

    // Return null if nothing found
    return null;
}

// Update an element with the given filter object
function update_element(element, filter) {
    console.debug(element.find('u').text(), filter);
    // Reset the element to the template
    element.html(filter_template.html());

    // Set the item type
    let item_type = filter['item_type'];
    if (item_type !== null) {
        element.find('.item-list option[selected]')
               .removeAttr('selected');
        element.find('.item-list option[data-key="' + item_type + '"]')
               .attr('selected', '');

        // Hide the unique selection if an item type is selected
        element.find('.unique-selection').hide();
        element.find('.unique-roll').hide();
    }

    // Set the unique
    let unique = filter['unique'];
    let unique_aspect = filter['unique_aspect'];
    if (unique !== false) {
        element.find('.unique-list option[selected]')
               .removeAttr('selected');
        element.find('.unique-list option[data-key="' + unique_aspect['name'] + '"]')
               .attr('selected', '');
        element.find('.unique-selection').fadeIn("slow");

        // Hide the item type selection if unique is selected
        element.find('.select-item-type').hide();
        // Show the unique roll if unique is selected
        element.find('.unique-roll').fadeIn("slow");
    }

    // Set the unique aspect
    if (unique !== false) {
        element.find('.unique-roll input').val(unique_aspect['value']);
        element.find('.unique-roll .comparison').html(
            comparison[unique_aspect['comparison']]
        );
        element.find('.unique-roll .comparison').data(
            'current',
            unique_aspect['comparison']
        );
    }

    // Set the minPower
    element.find('[data-key="minPower"] input').val(filter['minPower']);

    // Set the minimum greater affix count
    element.find('[data-key="minGreaterAffixCount"] input').val(
        filter['affixes']['pool']['greater_required']
    );

    // Set the minimum affix count
    element.find('[data-key="minCount"] input').val(
        filter['affixes']['pool']['total_required']
    );

    // Set the affixes
    let affixes = filter['affixes']['pool']['list'];
    for (let i = 0; i < affixes.length; i++) {
        let affix = affixes[i];
        add_affix(element, affix['name'], affix['comparison'], affix['value']);
    }

    // Set the required affixes
    let required_affixes = filter['affixes']['required'];
    for (let i = 0; i < required_affixes.length; i++) {
        let affix = required_affixes[i];
        add_affix(element, affix['affix']['name'], affix['affix']['comparison'],
            affix['affix']['value']
        );
        let affix_element = element.find('.affixes').children().last();
        let state_of_affix = affix['greater_required'] ? 'greater' : 'required';
        affix_element.find('[data-key="affix-pooling"]').html(
            affix_state[state_of_affix]
        );
        affix_element.find('[data-key="affix-pooling"]').data(
            'current',
            state_of_affix
        );
    }

    // Set the implicit affixes
    let implicit_affixes = filter['affixes']['implicit'];
    for (let i = 0; i < implicit_affixes.length; i++) {
        let affix = implicit_affixes[i];
        add_affix(element, affix['name'], affix['comparison'], affix['value']);
    }
}

// todo: change build_editor() and add_unique() to use update_element()

//endregion

////////////////////////////////////////////////////////////////////////////////////
//region Saving Utilities
////////////////////////////////////////////////////////////////////////////////////

// Parse an html element into a filter object
function parse_element(element) {
    let individual_filter = structuredClone(filter_part_template);
    let affix_base = {
        'name': '',
        'comparison': 'larger',
        'value': 0,
    };
    let required_affix_base = {
        affix: {...affix_base},
        'greater_required': false,
    };

    // Get the slot
    individual_filter['slot'] = element.find('u').text()
                                       .toLowerCase()
                                       .replace(/ /g, '_');

    // Get the item type
    let item_type = element.find('.item-list')
                           .children('option:selected').data('key');
    // noinspection EqualityComparisonWithCoercionJS
    if (item_type !== '' && item_type != undefined) {
        individual_filter['item_type'] = item_type;
    } else {
        individual_filter['item_type'] = null;
    }

    // Get the unique
    let unique = element.find('.unique-list')
                        .children('option:selected').data('key');
    // noinspection EqualityComparisonWithCoercionJS
    individual_filter['unique'] = unique !== '' && unique != undefined;

    // If a unique is selected build the unique aspect
    if (individual_filter['unique'] !== false) {
        let unique_aspect = {...affix_base};
        unique_aspect['name'] = unique;

        // Get the unique aspect
        unique_aspect['comparison'] = element.find('.unique-roll .comparison')
                                             .data('current');
        unique_aspect['value'] = +element.find('.unique-roll input').val();
        individual_filter['unique_aspect'] = unique_aspect;
    }

    // Get the minimum power
    individual_filter['minPower'] = +element.find('[data-key="minPower"] input')
                                            .val();

    // Get the minimum greater affix count
    individual_filter['affixes']['pool']['greater_required'] = +element
        .find('[data-key="minGreaterAffixCount"] input').val();

    // Get the minimum affix count
    individual_filter['affixes']['pool']['total_required'] = +element
        .find('[data-key="minCount"] input').val();

    // Loop over each affix in the affix list
    let affixes = element.find('.affixes').children();
    $.each(affixes, function (index, affix) {
        // Find the affix data
        let affix_element = $(affix);
        let affix_key = affix_element.data('key');
        let affix_compare = affix_element.find('[data-key="affix-comparison"]')
                                         .data('current');
        let affix_value = +affix_element.find('[data-key="affix-value"]')
                                        .val();
        let affix_state = affix_element.find('[data-key="affix-pooling"]')
                                       .data('current');

        // Build the affix object
        let affix_object = {...affix_base};
        affix_object['name'] = affix_key;
        affix_object['comparison'] = affix_compare;
        affix_object['value'] = affix_value;

        // Put the affix in the right list
        // Implicit Pool
        for (const [_, value] of Object.entries(implicit_affixes)) {
            if (value.includes(affix_key)) {
                individual_filter['affixes']['implicit'].push(affix_object);
                return;
            }
        }
        // Normal Pool
        if (affix_state === affix_states['one-of']) {
            individual_filter['affixes']['pool']['list'].push(affix_object);
        }
        // Required Pool
        else {
            let req_affix_object = {...required_affix_base};
            req_affix_object['affix'] = affix_object;
            req_affix_object['greater_required'] = affix_state === affix_states['greater'];

            individual_filter['affixes']['required'].push(req_affix_object);
        }
    });

    return individual_filter;
}

// To convert a filter object into a js-yaml-write filter
function convert_filter_part_for_yaml(filter_object) {
    return filter_object['unique']
        ? convert_unique_filter_part_for_yaml(filter_object)
        : convert_affix_filter_part_for_yaml(filter_object);
}

// To convert a unique filter object into a js-yaml-write filter
function convert_unique_filter_part_for_yaml(filter_object) {
    let filter_for_yaml = {
        'aspect': filter_object['unique_aspect'],
        'minPower': filter_object['minPower'],
        'minGreaterAffixCount': filter_object['affixes']['pool']['greater_required'],
    };

    //region Affixes
    // Everything into affixes, affixes are fixed
    if (filter_object['affixes']['pool']['list'].length !== 0
        || filter_object['affixes']['required'].length !== 0
        || filter_object['affixes']['implicit'].length !== 0) {
        filter_for_yaml['affixes'] = [];

        // Implicit Affixes
        for (let i = 0; i < filter_object['affixes']['implicit'].length; i++) {
            let affix = filter_object['affixes']['implicit'][i];
            filter_for_yaml['affixes'].push(affix);
        }
        // Required Affixes
        for (let i = 0; i < filter_object['affixes']['required'].length; i++) {
            let affix = filter_object['affixes']['required'][i];
            filter_for_yaml['affixes'].push(affix);
        }
        // Normal Affixes
        for (let i = 0; i < filter_object['affixes']['pool']['list'].length; i++) {
            let affix = filter_object['affixes']['pool']['list'][i];
            filter_for_yaml['affixes'].push(affix);
        }
    }
    // endregion

    return filter_for_yaml;
}

// To convert a non-unique filter object into a js-yaml-write filter
function convert_affix_filter_part_for_yaml(filter_object) {
    let filter_for_yaml = {};
    filter_for_yaml[filter_object['slot']] = {
        'minPower': filter_object['minPower'],
        'itemType': filter_object['item_type'] !== null
            ? filter_object['item_type']
            : get_synonym_if_has(filter_object['slot']),
    };

    //region Affixes
    // Implicit Affixes
    if (filter_object['affixes']['implicit'].length !== 0) {
        filter_for_yaml[filter_object['slot']]['inherentPool'] = [{
            'count': filter_object['affixes']['implicit'],
        }];
    }

    // Set up the affix pool for either required or normal affixes
    if (filter_object['affixes']['required'].length !== 0
        || filter_object['affixes']['pool']['list'].length !== 0) {
        filter_for_yaml[filter_object['slot']]['affixPool'] = [];
    }

    // Normal Affixes
    if (filter_object['affixes']['pool']['list'].length !== 0) {
        filter_for_yaml[filter_object['slot']]['affixPool'].push({
            'count': filter_object['affixes']['pool']['list'],
            'minCount': filter_object['affixes']['pool']['total_required'],
            'minGreaterAffixCount': filter_object['affixes']['pool']['greater_required'],
        });
    }

    // Required Affixes
    if (filter_object['affixes']['required'].length !== 0) {
        let required_pool = {
            'greater': [],
            'required': [],
        };

        // Separate required affixes into greater and required
        for (let i = 0; i < filter_object['affixes']['required'].length; i++) {
            let affix = filter_object['affixes']['required'][i];
            let affix_object = affix['affix'];
            let affix_state = affix['greater_required'] ? 'greater' : 'required';
            required_pool[affix_state].push(affix_object);
        }

        // Add the required affixes to the affix pool
        if (required_pool['greater'].length !== 0) {
            filter_for_yaml[filter_object['slot']]['affixPool'].push({
                'count': required_pool['greater'],
                'minGreaterAffixCount': required_pool['greater'].length,
            });
        }
        if (required_pool['required'].length !== 0) {
            filter_for_yaml[filter_object['slot']]['affixPool'].push({
                'count': required_pool['required'],
            });
        }
    }
    //endregion

    return filter_for_yaml;
}

// endregion

////////////////////////////////////////////////////////////////////////////////////
//region Loading and Saving Filters
////////////////////////////////////////////////////////////////////////////////////
let og_yaml = '';
// Parse the given filter
reader.onload = readerEvent => {
    let content = readerEvent.target.result;
    try {
        // Load the filter
        og_yaml = content;
        filter = jsyaml.load(content);

        // Search for and save D4LF-import comments
        let original_lines = content.split('\n');
        for (let i = 0; i < original_lines.length; i++) {
            if (original_lines[i].includes('# https://maxroll')) {
                found_imported_comments = original_lines[i] +
                    '\n' + original_lines[i + 1] + '\n';
                break;
            }
        }

        // Save the filter
        editor_data = parse_filter();
        editor_source = existing_filter;
        // Show the editor
        show_editor();
    } catch (e) {
        console.debug(content);
        console.debug(filter);
        console.error(e);
    }
}

// To convert a js-yaml-read filter into the same format as editor_layout
function parse_filter() {
    let filled_data = editor_layout;
    // Parse unique-to-slot mappings
    let unique_mapping = read_unique_slot_mapping(filter);
    let all_uniques_unslotted = unique_mapping === false;
    // Parse weapon slots
    let weapons = parse_weapons(unique_mapping);

    // Foreach over each slot in the editor layout
    for (let i = 0; i < editor_layout.length; i++) {
        let layout_item = editor_layout[i];
        let slot = layout_item.slot;

        // Skip blanks
        if (jQuery.isEmptyObject(layout_item)) {
            continue;
        }

        // If the slot is a weapon, assign the parsed weapon to it
        if (slot.includes('hand')) {
            if (weapons[slot] !== null) {
                // If array - Unique
                if (Array.isArray(weapons[slot])) {
                    layout_item['filters'] = search_filter_by(weapons[slot][0]);
                }
                // If string - Affix
                else {
                    layout_item['filters'] = search_filter_by(weapons[slot]);
                }
            }
            continue;
        }

        // If the slot is one assigned to a unique, assign the unique to it
        if (!all_uniques_unslotted) {
            if (unique_mapping.hasOwnProperty(slot)) {
                layout_item['filters'] = search_filter_by(unique_mapping[slot]);
                continue;
            }
            if (has_synonym(slot)) {
                if (unique_mapping.hasOwnProperty(get_synonym(slot))) {
                    layout_item['filters'] = search_filter_by(unique_mapping[get_synonym(
                        slot)]);
                    continue;
                }
            }
        }

        // Set the filter for the slot based solely on item type
        layout_item['filters'] = search_filter_by(null, slot);
    }

    // Add the unslotted uniques to the end of the editor layout
    // If all uniques are unslotted, add them all
    if (all_uniques_unslotted) {
        let uniques = filter['Uniques'];
        for (let i = 0; i < uniques.length; i++) {
            let unique = uniques[i];
            let layout_item = {slot: 'unique', filters: unique};
            filled_data.push(layout_item);
        }
    }
    // If some uniques are slotted, add just the unslotted ones
    else {
        let uniques = filter['Uniques'];
        for (let i = 0; i < uniques.length; i++) {
            let unique = uniques[i];
            let aspect = Array.isArray(unique['aspect'])
                ? unique['aspect'][0]
                : (typeof unique['aspect'] === 'object'
                    ? unique['aspect']['name']
                    : unique['aspect']);
            // if aspect is not one of the values in the mapping, add it to the end
            if (!Object.values(unique_mapping).includes(aspect)) {
                let layout_item = {slot: 'unique', filters: unique};
                filled_data.push(layout_item);
            }
        }
    }

    return filled_data;
}

// To convert the editor into a js-yaml-write filter
function save_filter() {
    let filter_for_yaml = {
        'Uniques': [],
        'Affixes': [],
    };

    // For each div in #filters, parse the filter
    let filters = [];
    $('#filters').children().each(function () {
        // Parse the element into a filter
        let element = $(this);
        let filter = parse_element(element);

        //region Skip Unused Filters
        // Skip ignore elements
        let ignore = element.attr('ignore');
        if (ignore === false || ignore === '') {
            return;
        }

        // Skip elements equivalent to the template
        let template = filter_template.html();
        let current = element.html();
        if (template === current) {
            return;
        }

        // Skip empty filters
        let emptyAffixes = filter['affixes']['pool']['list'].length === 0
            && filter['affixes']['required'].length === 0
            && filter['affixes']['implicit'].length === 0;
        let emptyEmpty = filter['item_type'] === null
            && filter['unique'] === false
            && filter['minPower'] === '0'
            && emptyAffixes;
        let emptyWeapon = filter['slot'].includes('hand')
            && filter['item_type'] === null
            && filter['unique'] === false;
        let emptyUnique = filter['slot'] === 'unique'
            && filter['unique'] === false
            && filter['unique_aspect']['value'] === '0'
            && filter['minPower'] === '0'
            && emptyAffixes;
        let emptyGear = filter['slot'] !== 'unique'
            && filter['item_type'] === null
            && filter['unique'] === false
            && filter['minPower'] === '0'
            && emptyAffixes;
        if (emptyEmpty || emptyWeapon || emptyUnique || emptyGear) {
            return;
        }
        //endregion

        // Save the filter
        filters.push(filter);
    });

    // Check each filter: if it's a unique, add it to the Uniques, else Affixes
    for (let i = 0; i < filters.length; i++) {
        let unique = filters[i]['unique'] === true;
        let filter = convert_filter_part_for_yaml(filters[i]);
        if (unique) {
            filter_for_yaml['Uniques'].push(filter);
        } else {
            filter_for_yaml['Affixes'].push(filter);
        }
    }

    // Add unique-to-slot mapping
    let unique_mapping = build_unique_slot_mapping(filters);
    if (unique_mapping !== false) {
        filter_for_yaml['Affixes'].push(
            {
                [mapping_label + mapping_label_separator + unique_mapping]:
                mapping_template_body
            }
        );
    }

    // Write the filter to a js-yaml string
    let yaml_uniques = jsyaml.dump(
        {'Uniques': filter_for_yaml['Uniques']},
        {
            lineWidth: -1,
            flowLevel: 3, // Only Aspects
        }
    );
    let yaml_affixes = jsyaml.dump(
        {'Affixes': filter_for_yaml['Affixes']},
        {
            lineWidth: -1,
            flowLevel: 7, // Only Affixes
        }
    );
    let yaml_filter = yaml_header_comment
        + (found_imported_comments !== ''
            ? '# Build originally Generated via Import:\n'
            + found_imported_comments
            : '')
        + '\n'
        + yaml_uniques
        + (filter_for_yaml['Uniques'].length > 0
            ? '\n#####################################\n\n'
            : '')
        + yaml_affixes;

    //region Debugging YAML
    /*
    let EOL = '\n';
    $('#og-json').text(JSON.stringify(filter, null, ' ').replace(/\r\n/g, EOL));
    $('#og-yaml').text(og_yaml.replace(/\r\n/g, EOL));
    $('#ns-json').text(JSON.stringify(filter_for_yaml, null, ' ').replace(
        /\r\n/g,
        EOL
    ));
    $('#ns-yaml').text(yaml_filter.replace(/\r\n/g, EOL));
     */
    //endregion

    // Save the filter
    let blob = new Blob([yaml_filter], {type: 'text/yaml'});
    let url = window.URL.createObjectURL(blob);

    //region Downloading the file
    let straight_download = function (uri) {
        let a = document.createElement('a');
        a.href = url;
        a.download = 'filter.yaml';
        a.click();
    };

    let isFileSaverSupported;
    try {
        isFileSaverSupported = !!new Blob;
    } catch (e) {
        isFileSaverSupported = false;
    }

    if (isFileSaverSupported) {
        saveAs(blob, 'edited_' + file_name);
    } else {
        straight_download(url);
    }
    //endregion
}

//endregion
