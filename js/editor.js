// noinspection JSCheckFunctionSignatures
// region Variables
//region Selectors
let start = $('#start'); // Splash page
let editor = $('#editor'); // Editor page
let filter_template = $('#base-filter > div');
let affix_template = $('#base-affix');
let close_template = $('#base-unique-close');
let blank_filter = $('#blank div');
let input = document.createElement('input');
//endregion

//region Constants
//region For the Editor
const original_editor = editor.clone();
const editor_layout = [
    {slot: 'helm', filters: null,},
    {slot: 'main_hand', filters: null,},
    {},

    {slot: 'chest', filters: null,},
    {slot: 'off_hand', filters: null,},
    {slot: 'amulet', filters: null,},

    {slot: 'gloves', filters: null,},
    {},
    {slot: 'ring', filters: null,},

    {slot: 'pants', filters: null,},
    {slot: 'left_hand', filters: null,},
    {slot: 'other_ring', filters: null,},

    {slot: 'boots', filters: null,},
    {slot: 'right_hand', filters: null,},
];
const one_handed_weapons = [
    'Axe',
    'Dagger',
    'Mace',
    'Scythe',
    'Sword',
    'Wand',
];
const off_hand_weapons = [
    'Focus',
    'Shield',
    'Totem',
];
const two_handed_weapons = [
    'Axe2H',
    'Bow',
    'Crossbow2H',
    'Mace2H',
    'Polearm',
    'Scythe2H',
    'Staff',
    'Sword2H',
];
const implicit_affixes = {
    'boots': [
        'evade_grants_movement_speed_for_second',
        'attacks_reduce_evades_cooldown_by_seconds',
        'maximum_evade_charges',
    ],
    // 'Inherent' in D4LF
    // https://d4builds.gg/database/gear-affixes/
}
const comparison = {
    'larger': '&#10095;',
    'smaller': '&#10094;',
};
const new_filter = true;
const existing_filter = false;
const synonyms = {
    'helm': 'head',
    'chest': 'chest armor',
    'amulet': 'neck',
    'gloves': 'hands',
    'ring': 'ring',
    'pants': 'legs',
    'other_ring': 'ring',
    'boots': 'feet',
};
//endregion

//region For unique-to-slot mapping
const mapping_label = 'd4lf-editor_uniques_mapping';
const mapping_label_separator = '------------';
const mapping_separator = '--';
const mapping_key_separator = ':';
//endregion

//region For abbreviating affixes
const affix_abbreviations = {
    'evade_grants_movement_speed_for_second': 'evade gives speed',
    'attacks_reduce_evades_cooldown_by_seconds': 'attacks reduce evade cd',
    'maximum_evade_charges': 'max evades',
    'cooldown_reduction': 'cdr',
    'resistance_to_all_elements': 'resist all',
    'maximum_life': 'max hp',
    'critical_strike_chance': 'crit chance',
    'critical_strike_damage': 'crit damage',
    'attack_speed': 'atk speed',
    'movement_speed': 'move speed',
}
const affix_dynamic_abbreviations = {
    'lucky_hit_': [
        ['lucky_hit', 'lucky hit'],
        ['critical_strikes_have', '(crit)'],
        ['_up_to_a_chance_to', ':'],
        ['for_seconds', ''],
    ],
    'chance_for_': [
        ['chance_for', 'cast:'],
        ['to_cast_twice', ''], // x2, but have to handle it with custom logic,
        ['a_second', ''], // x2, but have to handle it with custom logic
        ['when_cast', ''],
    ],
    'resource_generation_w': [
        ['resource_generation', 'extra gen:'],
    ],
    'critical_strike_chance_against_': [
        ['critical_strike_chance_against', 'crit vs:'],
    ],
};
//endregion

//region For the Editor itself
const version = '0.0.0(season5)';
const supported_d4lf = 'v5.7.3';
const yaml_header_comment = ''
    + '# Generated by D4LF-editor version ' + version + '\n'
    + '# For D4LF version ' + supported_d4lf + '\n' + '\n';
// Writing the version numbers to the web page
$('.version').text(version);
$('.supported-d4lf').text(supported_d4lf);
//endregion
//endregion

//region Working Data
let editor_source = null;
let editor_data = editor_layout; // Editor working data
let filter = {}; // Loaded filter data
let file = null; // Uploaded file
let reader = new FileReader(); // File reader
//endregion
//endregion

////////////////////////////////////////////////////////////////////////////////////
//region Editor data
////////////////////////////////////////////////////////////////////////////////////

// List of all affixes
$.getJSON(
    'https://raw.githubusercontent.com/aeon0/d4lf/main/assets/lang/enUS/affixes.json',
    function (data) {
        $.each(data, function (key, value) {
            $('.affix-list').append(
                '<option data-key="' + key + '" data-value="' + value + '">' +
                value +
                '</option>'
            );
        });
    }
);

// List of just weapons
$.getJSON(
    'https://raw.githubusercontent.com/aeon0/d4lf/main/assets/lang/enUS/item_types.json',
    function (data) {
        $.each(data, function (key, value) {
            // noinspection JSUnresolvedReference
            let key_check = key.toLowerCase();
            if (
                key_check.includes('axe')
                || key_check.includes('bow')
                || key_check.includes('dagger')
                || key_check.includes('focus')
                || key_check.includes('mace')
                || key_check.includes('totem')
                || key_check.includes('polearm')
                || key_check.includes('scythe')
                || key_check.includes('shield')
                || key_check.includes('staff')
                || key_check.includes('sword')
                || key_check.includes('wand')
            ) {
                $('.item-list').append(
                    '<option data-key="' + key + '" data-value="' + value + '">' +
                    capitalize(value) +
                    '</option>'
                );
            }
        });
    }
);

// List of all uniques
$.getJSON(
    'https://raw.githubusercontent.com/aeon0/d4lf/main/assets/lang/enUS/uniques.json',
    function (data) {
        $.each(data, function (key, value) {
            // Filter out some of the dud values
            if (key.toString().includes('(')
                || key.toString().includes('[')
                || key.toString().includes('boost')
                || value['desc'].toLowerCase().includes('test item')
                || value['desc'].toLowerCase().includes('tbd')) {
                return;
            }

            $('.unique-list').append(
                '<option data-key="' + key + '" data-value="' + value['desc'] + '">' +
                capitalize(key) +
                '</option>'
            );
        });
    }
);
//endregion

////////////////////////////////////////////////////////////////////////////////////
//region Editor Utilities
////////////////////////////////////////////////////////////////////////////////////

// https://stackoverflow.com/a/1026087/1843510
function capitalize(string) {
    string = string.replace(/_/g, ' ');
    return string.charAt(0).toUpperCase() + string.slice(1);
}

// To get to the editor page, while loading data or just from scratch
function to_editor(filter_selection) {
    // Fail out
    if (filter_selection !== new_filter
        && filter_selection !== existing_filter) {
        return;
    }

    // Open a file dialog to choose a filter
    if (filter_selection === existing_filter) {
        // The .yaml file dialog
        input.type = 'file';
        input.accept = '.yaml';
        input.click();
        // Triggers input.onchange below, then reader.onload
    } else {
        editor_source = new_filter;
        show_editor();
    }
}

// Load the given filter file
input.onchange = e => {
    file = e.target.files[0];
    reader.readAsText(file, 'UTF-8');
}

// Actually build and show the editor page
function show_editor() {
    // Clear the page
    start.hide();

    // Show the editor
    $('body').css('maxWidth', '70em');
    editor.show();
    // Build the editor
    build_editor();
}

// Build the editor HTML from template code (#base-filter)
function build_editor() {
    editor.html(original_editor.html());
    console.debug(editor_data);

    // Iterate over equipment slots
    editor_data.forEach(function (layout_item) {
        // Skip slots labelled 'unique'
        if (layout_item.slot === 'unique') {
            return;
        }
        // Fill blank slots
        if (jQuery.isEmptyObject(layout_item)) {
            (blank_filter.clone()).insertBefore('#controls');
            return;
        }

        // Build the editor slots
        // Copy the template
        let new_filter = filter_template.clone();
        // Fill basic data, if it's a new filter
        if (editor_source === new_filter || layout_item.filters === null) {
            // Fill the ID into the template
            new_filter.attr('id', layout_item.slot);
            new_filter.find('u').text(capitalize(layout_item.slot));

            // Show Item-Type selector for weapons
            if (layout_item.slot.includes('hand')) {
                new_filter.find('.select-item-type').show();
            }
        }
        // Fill the filter data, if it's an existing filter
        else if (editor_source === existing_filter) {
            // Fill the ID into the template
            new_filter.attr('id', layout_item.slot);
            new_filter.find('u').text(capitalize(layout_item.slot));

            // Fill the minPower
            if (layout_item.filters.hasOwnProperty('minPower')) {
                new_filter
                    .find('[data-key="minPower"] input')
                    .val(layout_item.filters['minPower']);
            }

            // Fill the itemType
            if (layout_item.filters.hasOwnProperty('itemType')) {
                let item_type = layout_item.filters['itemType'];
                if (Array.isArray(item_type)) {
                    item_type = item_type[0];
                }
                // Set the item type
                new_filter
                    .find('.item-list option[data-key="' + item_type + '"]')
                    .attr('selected', '');
                // Unselect the default option
                new_filter.find('.item-list option').first().removeAttr('selected');
                if (layout_item.slot.includes('hand')) {
                    // Hide unique selection if item type is selected
                    new_filter.find('.unique-selection').hide();
                }
            }

            // Fill the Unique
            if (layout_item.filters.hasOwnProperty('aspect')) {
                let unique = layout_item.filters['aspect'];
                if (Array.isArray(unique)) {
                    unique = unique[0];
                }
                // Set the unique
                new_filter
                    .find('.unique-list option[data-key="' + unique + '"]')
                    .attr('selected', '');
                // Unselect the default option
                new_filter.find('.unique-list option')
                          .first()
                          .removeAttr('selected');
                // Show the unique roll if unique is selected
                new_filter.find('.unique-roll').show();
                // Hide the item type selection if unique is selected
                new_filter.find('.select-item-type').hide();
            }

            // Fill the Unique aspect roll
            if (layout_item.filters.hasOwnProperty('aspect')) {
                let roll = layout_item.filters['aspect'];
                if (Array.isArray(roll)) {
                    let value = '0';
                    if (roll.length >= 2) {
                        value = roll[1];
                    }
                    let compare = ['larger', comparison['larger']];
                    if (roll.length >= 3) {
                        compare = [roll[2], comparison[roll[2]]];
                    }
                    new_filter.find('.unique-roll input').val(value);
                    new_filter.find('.unique-roll .comparison').html(compare[1]);
                    new_filter.find('.unique-roll .comparison').data(
                        'current',
                        compare[0]
                    );
                }
            }

            // Fill minGreaterAffixCount
            if (layout_item.filters.hasOwnProperty('affixPool')
                && layout_item.filters['affixPool'][0].hasOwnProperty('minGreaterAffixCount')) {
                new_filter
                    .find('[data-key="minGreaterAffixCount"] input')
                    .val(layout_item.filters['affixPool'][0]['minGreaterAffixCount']);
            }
            // Again, for uniques
            if (layout_item.filters.hasOwnProperty('minGreaterAffixCount')) {
                new_filter
                    .find('[data-key="minGreaterAffixCount"] input')
                    .val(layout_item.filters['minGreaterAffixCount']);
            }

            // Fill minCount
            if (layout_item.filters.hasOwnProperty('minCount')) {
                new_filter
                    .find('[data-key="minCount"] input')
                    .val(layout_item.filters['minCount']);
            }

            // todo: this should be a loop over `layout_item.filters['affixPool']`,
            //  to account for multiple pools (e.g. with different minCount)
            // Fill affixes
            if (layout_item.filters.hasOwnProperty('affixPool')
                && layout_item.filters['affixPool'][0].hasOwnProperty('count')
                && layout_item.filters['affixPool'][0]['count'].length > 0) {
                // Foreach affix in the affixPool.count
                for (let i = 0; i < layout_item.filters['affixPool'][0]['count'].length; i++) {
                    let affix = layout_item.filters['affixPool'][0]['count'][i];
                    // noinspection DuplicatedCode
                    let key = '';
                    let value = 0;
                    let compare = 'larger';

                    // Parse different layouts of affixes
                    if (Array.isArray(affix)) {
                        key = affix[0];
                        if (affix.length >= 2) {
                            value = affix[1];
                        }
                        if (affix.length >= 3) {
                            compare = affix[2];
                        }
                    }
                    else if (typeof affix === 'object') {
                        key = affix['name'];
                        if (affix.hasOwnProperty('value')) {
                            value = affix['value'];
                        }
                        if (affix.hasOwnProperty('comparison')) {
                            compare = affix['comparison'];
                        }
                    }
                    else if (typeof affix === 'string') {
                        key = affix;
                    }

                    // Add the affix to the affix list
                    add_affix(
                        new_filter,
                        key,
                        compare,
                        value
                    );
                }
            }
            // Again, for uniques
            if (layout_item.filters.hasOwnProperty('affix')
                && layout_item.filters['affix'].length > 0) {
                // Foreach affix in the affixPool.count
                for (let i = 0; i < layout_item.filters['affix'].length; i++) {
                    let affix = layout_item.filters['affix'][i];
                    // noinspection DuplicatedCode
                    let key = '';
                    let value = 0;
                    let compare = 'larger';

                    // Parse different layouts of affixes
                    if (Array.isArray(affix)) {
                        key = affix[0];
                        if (affix.length >= 2) {
                            value = affix[1];
                        }
                        if (affix.length >= 3) {
                            compare = affix[2];
                        }
                    }
                    else if (typeof affix === 'object') {
                        key = affix['name'];
                        if (affix.hasOwnProperty('value')) {
                            value = affix['value'];
                        }
                        if (affix.hasOwnProperty('comparison')) {
                            compare = affix['comparison'];
                        }
                    }
                    else if (typeof affix === 'string') {
                        key = affix;
                    }

                    // Add the affix to the affix list
                    add_affix(
                        new_filter,
                        key,
                        compare,
                        value
                    );
                }
            }

            // Fill inherent affixes
            if (layout_item.filters.hasOwnProperty('inherentPool')
                && layout_item.filters['inherentPool'][0].hasOwnProperty('count')
                && layout_item.filters['inherentPool'][0]['count'].length > 0) {
                // Foreach affix in the affixPool.count
                for (let i = 0; i < layout_item.filters['inherentPool'][0]['count'].length; i++) {
                    let affix = layout_item.filters['inherentPool'][0]['count'][i];
                    // noinspection DuplicatedCode
                    let key = '';
                    let value = 0;
                    let compare = 'larger';

                    // Parse different layouts of affixes
                    if (Array.isArray(affix)) {
                        key = affix[0];
                        if (affix.length >= 2) {
                            value = affix[1];
                        }
                        if (affix.length >= 3) {
                            compare = affix[2];
                        }
                    }
                    else if (typeof affix === 'object') {
                        key = affix['name'];
                        if (affix.hasOwnProperty('value')) {
                            value = affix['value'];
                        }
                        if (affix.hasOwnProperty('comparison')) {
                            compare = affix['comparison'];
                        }
                    }
                    else if (typeof affix === 'string') {
                        key = affix;
                    }

                    // Add the affix to the affix list
                    add_affix(
                        new_filter,
                        key,
                        compare,
                        value
                    );
                }
            }
        }

        // Place the editor slot
        new_filter.insertBefore('#controls');
    })

    // Iterate over uniques
    editor_data.forEach(function (unique) {
        // Skip non-uniques
        if (unique.slot !== 'unique') {
            return;
        }

        // Add the unique
        add_unique(unique.filters);
    });
}

// Return to the home page
function to_home() {
    filter = {};
    editor.html(original_editor.html());

    start.show();
    editor.hide();
    $('body').css('maxWidth', '38em');
}

// Check if affix is one that is dynamically abbreviated, and abbreviate it if so
function abbreviate_affix(affix_key) {
    // Abbreviate the affix if the key is in the list or if it's too long
    if (affix_abbreviations.hasOwnProperty(affix_key)) {
        return affix_abbreviations[affix_key];
    }

    // If key starts with a dynamic abbreviation, replace each segment of it
    for (const [abbreviation, replacements]
        of Object.entries(affix_dynamic_abbreviations)) {
        if (affix_key.startsWith(abbreviation)) {
            for (const [segment, replacement] of replacements) {
                affix_key = affix_key.replace(segment, replacement);
            }
        }
    }

    // Replace underscores with spaces
    affix_key = affix_key.replace(/_/g, ' ');

    // Abbreviate the affix if it's too long
    if (affix_key.length > 38) {
        affix_key = affix_key.substring(0, 35) + '...';
    }

    return affix_key;
}

// Build list of affixes in the element
function build_affixes(element) {
    let affixes = element.find('.affixes').children();
    let affix_list = [];

    // Iterate over the affixes
    affixes.each(function () {
        let affix = $(this).find('p').data('key');
        affix_list.push(affix);
    });

    return affix_list;
}

//endregion

////////////////////////////////////////////////////////////////////////////////////
//region Editor UX
////////////////////////////////////////////////////////////////////////////////////

// Alternate the comparison operator for an aspect or affix
function change_comparison(element) {
    let current_comparison = element.data('current');
    if (current_comparison === 'larger') {
        element.data('current', 'smaller');
        element.html(comparison['smaller']);
    } else {
        element.data('current', 'larger');
        element.html(comparison['larger']);
    }
}

// Show both Item-Type and Unique selectors without values, with values: only
// show one or the other
function toggle_unique_or_item(element) {
    let value = element.children('option:selected').val();

    // Show both
    if (value === '') {
        $('.select-item-type').fadeIn("slow");
        $('.unique-selection').fadeIn("slow");
    }
    // Hide the other
    else {
        let parent_class = element.parent().attr('class');

        if (parent_class === 'select-item-type') {
            element.parent().parent().find('.unique-selection').hide();
        } else {
            element.parent().parent().find('.select-item-type').hide();
        }
    }
}

// Show the Unique sub-option to control the Unique's aspect only when a Unique
// is selected
function toggle_unique_aspect(element) {
    let value = element.children('option:selected').val();

    // Show the Unique sub-option for the Unique aspect
    if (value === '') {
        element.parent().parent().find('.unique-roll').hide();
    }
    // Hide the Unique sub-option
    else {
        element.parent().parent().find('.unique-roll').fadeIn("slow");
    }
}

// Add an affix to the affix list
function add_affix(element,
                   affix_key = null,
                   affix_compare = null,
                   affix_compare_value = null) {
    let affix_value;
    if (affix_key !== null) {
        element = element.find('.affix-list').parent();
        let affixes = element.find('select');
        affix_value = affixes.find('option[data-key="' + affix_key + '"]').data('value');
    } else {
        // Get the affix key and value
        let affix = element.find('select').children('option:selected');
        affix_key = affix.data('key');
        affix_value = affix.data('value');
    }

    // Bail if affix already in list
    let current_affixes = build_affixes(element.parent());
    if (current_affixes.includes(affix_key)) {
        return;
    }

    // Bail if no value
    if (affix_value === '') {
        return;
    }

    // Add the affix to .affixes, based off of #base-affix
    let new_affix = affix_template.clone();
    new_affix.show();
    new_affix.fadeOut(0);

    // Set the affix key and value
    let affix_text = new_affix.find('p');
    affix_text.data('key', affix_key);
    affix_text.text(affix_value);

    // Abbreviate the affix if it's too long, or if it's on the list with shorter names
    let abbr = abbreviate_affix(affix_key);
    let no__affix_key = affix_key.replace(/_/g, ' ');
    if (abbr !== no__affix_key) {
        affix_text.html('<abbr title="' + affix_value + '">' + abbr + '</abbr>');
    }

    // Add in the comparison and value, if they were passed
    if (affix_compare !== null) {
        let compare = new_affix.find('.button');
        compare.html(comparison[affix_compare]);
        compare.data('current', affix_compare);
    }
    if (affix_compare_value !== null) {
        new_affix.find('input').val(affix_compare_value);
    }

    // Add the affix to the affix list
    element.parent().find('.affixes').append(new_affix);
    new_affix.fadeIn("slow");
}

// Add a new filter, for uniques
function add_unique(filter_override = null) {
    // Build a new filter element from the template
    let new_unique = filter_template.clone();

    // Add an id with a unique number, that isn't already in use
    let random_id = Math.floor(Math.random() * 10000);
    while ($('#unique-' + random_id).length) {
        random_id = Math.floor(Math.random() * 10000);
    }
    new_unique.attr('id', 'unique-' + random_id);

    // Add a close button to the new unique from the template
    let close_button = close_template.clone();
    close_button.show();
    close_button.insertBefore(new_unique.find('u'));

    // Set up the template for uniques
    new_unique.find('u').text('Unique');
    new_unique.find('.select-item-type').hide();
    new_unique.find('.unique-roll').show();
    new_unique.show();
    new_unique.fadeOut(0);
    // Remove the empty unique option
    new_unique.find('.unique-selection select').children().first().remove();
    // Remove the ? from the unique label
    new_unique.find('.unique-selection small').text('Unique');

    // Fill from an existing filter
    if (filter_override !== null) {
        // Fill the minPower
        if (filter_override.hasOwnProperty('minPower')) {
            new_unique
                .find('[data-key="minPower"] input')
                .val(filter_override['minPower']);
        }

        // Fill the Unique
        if (filter_override.hasOwnProperty('aspect')) {
            let unique = filter_override['aspect'];
            if (Array.isArray(unique)) {
                unique = unique[0];
            }
            // Set the unique
            new_unique
                .find('.unique-list option[data-key="' + unique + '"]')
                .attr('selected', '');
            // Unselect the default option
            new_unique.find('.unique-list option')
                      .first()
                      .removeAttr('selected');
            // Show the unique roll if unique is selected
            new_unique.find('.unique-roll').show();
            // Hide the item type selection if unique is selected
            new_unique.find('.select-item-type').hide();
        }

        // Fill the Unique aspect roll
        if (filter_override.hasOwnProperty('aspect')) {
            let roll = filter_override['aspect'];
            if (Array.isArray(roll)) {
                let value = '0';
                if (roll.length >= 2) {
                    value = roll[1];
                }
                let compare = ['larger', comparison['larger']];
                if (roll.length >= 3) {
                    compare = [roll[2], comparison[roll[2]]];
                }
                new_unique.find('.unique-roll input').val(value);
                new_unique.find('.unique-roll .comparison').html(compare[1]);
                new_unique.find('.unique-roll .comparison').data(
                    'current',
                    compare[0]
                );
            }
        }

        // Fill minGreaterAffixCount
        if (filter_override.hasOwnProperty('minGreaterAffixCount')) {
            new_unique
                .find('[data-key="minGreaterAffixCount"] input')
                .val(filter_override['minGreaterAffixCount']);
        }

        // Fill minCount
        if (filter_override.hasOwnProperty('minCount')) {
            new_filter
                .find('[data-key="minCount"] input')
                .val(filter_override['minCount']);
        }

        // Fill affixes
        if (filter_override.hasOwnProperty('affix')
            && filter_override['affix'].length > 0) {
            // Foreach affix in the affixPool.count
            for (let i = 0; i < filter_override['affix'].length; i++) {
                let affix = filter_override['affix'][i];
                // noinspection DuplicatedCode
                let key = '';
                let value = 0;
                let compare = 'larger';

                // Parse different layouts of affixes
                if (Array.isArray(affix)) {
                    key = affix[0];
                    if (affix.length >= 2) {
                        value = affix[1];
                    }
                    if (affix.length >= 3) {
                        compare = affix[2];
                    }
                }
                else if (typeof affix === 'object') {
                    key = affix['name'];
                    if (affix.hasOwnProperty('value')) {
                        value = affix['value'];
                    }
                    if (affix.hasOwnProperty('comparison')) {
                        compare = affix['comparison'];
                    }
                }
                else if (typeof affix === 'string') {
                    key = affix;
                }

                // Add the affix to the affix list
                add_affix(
                    new_unique,
                    key,
                    compare,
                    value
                );
            }
        }

        // Fill inherent affixes
        if (filter_override.hasOwnProperty('inherentPool')
            && filter_override['inherentPool'][0].hasOwnProperty('count')
            && filter_override['inherentPool'][0]['count'].length > 0) {
            // Foreach affix in the affixPool.count
            for (let i = 0; i < filter_override['inherentPool'][0]['count'].length; i++) {
                let affix = filter_override['inherentPool'][0]['count'][i];
                // noinspection DuplicatedCode
                let key = '';
                let value = 0;
                let compare = 'larger';

                // Parse different layouts of affixes
                if (Array.isArray(affix)) {
                    key = affix[0];
                    if (affix.length >= 2) {
                        value = affix[1];
                    }
                    if (affix.length >= 3) {
                        compare = affix[2];
                    }
                }
                else if (typeof affix === 'object') {
                    key = affix['name'];
                    if (affix.hasOwnProperty('value')) {
                        value = affix['value'];
                    }
                    if (affix.hasOwnProperty('comparison')) {
                        compare = affix['comparison'];
                    }
                }
                else if (typeof affix === 'string') {
                    key = affix;
                }

                // Add the affix to the affix list
                add_affix(
                    new_unique,
                    key,
                    compare,
                    value
                );
            }
        }
    }

    // Add the unique to the unique list
    new_unique.insertAfter('#uniques');
    new_unique.fadeIn(800);
}

//endregion

////////////////////////////////////////////////////////////////////////////////////
//region Loading Utilities
////////////////////////////////////////////////////////////////////////////////////

// Check for an existing unique-to-slot mapping, and parse it if it exists
function read_unique_slot_mapping(filter) {
    let uniques = filter['Uniques'];
    let affixes = filter['Affixes'];

    // Build simple list of aspect names of uniques
    let unique_aspects = [];
    for (let i = 0; i < uniques.length; i++) {
        let unique = uniques[i];
        let aspect = unique['aspect'][0];
        unique_aspects.push(aspect);
    }

    // Foreach array element, check if it's a unique-to-slot mapping
    for (let i = 0; i < affixes.length; i++) {
        let affix = affixes[i];
        // Get the one key in the object
        let key = Object.keys(affix)[0];
        // Check if the key is a unique-to-slot mapping
        if (key.startsWith(mapping_label)) {
            // Get just the mapping data
            let mapping = key.split(mapping_label_separator)[1];
            // Split maps into individual mappings
            let mappings = mapping.split(mapping_separator);

            // Build a mapping object
            let mapping_data = {};
            for (let j = 0; j < mappings.length; j++) {
                // Split the mapping into key and value
                let mapping_parts = mappings[j].split(mapping_key_separator);
                // Check that the mapping  data is valid
                if (mapping_parts.length !== 2) {
                    continue;
                }
                // Check that there is a unique for the mapping
                if (!unique_aspects.includes(mapping_parts[1])) {
                    continue;
                }

                // Add the mapping to the mapping object
                mapping_data[mapping_parts[0]] = mapping_parts[1];
            }

            // Check that the mapping object has data
            if (jQuery.isEmptyObject(mapping_data)) {
                continue;
            }

            // Return the mapping data
            return mapping_data;
        }
    }

    return false;
}

// Check for weapon filters, and fit them to all four weapon slots
function parse_weapons(unique_mapping) {
    //region Setup
    let weapons = {
        'main_hand': null,
        'off_hand': null,
        'left_hand': null,
        'right_hand': null,
    }
    let found_weapon_types = [];

    let number_weapons = 0;
    let number_1H_weapons = 0;
    let number_2H_weapons = 0;
    let number_off_hand_weapons = 0;

    // Find all weapon filters
    for (let i = 0; i < filter['Affixes'].length; i++) {
        let filter_item = filter['Affixes'][i];
        let name = Object.keys(filter_item)[0];
        let item_type = filter_item[name]['itemType'];

        // Don't support multiple item types in a single filter
        // Make item_type the first type if it's an array of types
        if (Array.isArray(item_type)) {
            item_type = item_type[0];
        }

        // Record the weapon type
        if (one_handed_weapons.includes(item_type)) {
            number_1H_weapons++;
            found_weapon_types.push({'name': name, 'type': item_type});
        } else if (two_handed_weapons.includes(item_type)) {
            number_2H_weapons++;
            found_weapon_types.push({'name': name, 'type': item_type});
        } else if (off_hand_weapons.includes(item_type)) {
            number_off_hand_weapons++;
            found_weapon_types.push({'name': name, 'type': item_type});
        }
    }
    //endregion

    //region Unique Assignments
    // Assign unique mappings to weapons, if they exist, then make all the other
    // weapon assignments haphazardly since it came out of the editor
    if (unique_mapping !== false) {
        // Assign unique mappings to weapons
        for (const [key, value] of Object.entries(unique_mapping)) {
            if (weapons.hasOwnProperty(key)) {
                weapons[key] = [value];
            }
        }
        // Assign found weapons - their names must be free if this was through the
        // filter already
        for (let i = 0; i < found_weapon_types.length; i++) {
            let weapon = found_weapon_types[i];
            weapons[weapon['name']] = weapon['name'];
        }

        return weapons;
    }
    //endregion

    /*
    console.debug(
        'found:', found_weapon_types,
        '1H:', number_1H_weapons,
        '2H:', number_2H_weapons,
        'OH:', number_off_hand_weapons,
    );
    */

    //region Rule Assignments
    // Assign weapons to slots
    // Assign 2H weapons to main-hand and off-hand, if they exist
    if (number_2H_weapons > 0) {
        for (let i = 0; i < found_weapon_types.length; i++) {
            let weapon = found_weapon_types[i];
            if (two_handed_weapons.includes(weapon['type'])) {
                if (weapons['main_hand'] === null) {
                    weapons['main_hand'] = weapon['name'];
                } else {
                    if (weapons['off_hand'] === null) {
                        weapons['off_hand'] = weapon['name'];
                    }
                }
            }
        }
    }
    // Assign off-hand weapons to off-hand/right-hand
    if (number_off_hand_weapons > 0) {
        if (number_2H_weapons === 0 && weapons['off_hand'] === null) {
            for (let i = 0; i < found_weapon_types.length; i++) {
                let weapon = found_weapon_types[i];
                if (off_hand_weapons.includes(weapon['type'])) {
                    weapons['off_hand'] = weapon['name'];
                }
            }
        } else {
            for (let i = 0; i < found_weapon_types.length; i++) {
                let weapon = found_weapon_types[i];
                if (off_hand_weapons.includes(weapon['type'])) {
                    weapons['right_hand'] = weapon['name'];
                }
            }
        }
    }
    // Assign 1H weapons to main-hand/left-hand (and off-hand/right-hand, if
    // there's still more, and each is empty)
    if (number_1H_weapons > 0) {
        for (let i = 0; i < found_weapon_types.length; i++) {
            let weapon = found_weapon_types[i];
            if (one_handed_weapons.includes(weapon['type'])) {
                // noinspection DuplicatedCode
                if (weapons['main_hand'] === null) {
                    weapons['main_hand'] = weapon['name'];
                } else {
                    if (weapons['off_hand'] === null) {
                        weapons['off_hand'] = weapon['name'];
                    } else {
                        if (weapons['left_hand'] === null) {
                            weapons['left_hand'] = weapon['name'];
                        } else {
                            if (weapons['right_hand'] === null) {
                                weapons['right_hand'] = weapon['name'];
                            }
                        }
                    }
                }
            }
        }
    }
    // Try to assign any weapons that are left over and are not already assigned
    for (let i = 0; i < found_weapon_types.length; i++) {
        let weapon = found_weapon_types[i];

        // Check that weapon name is not already assigned
        if (Object.values(weapons).includes(weapon['name'])) {
            continue;
        }

        // noinspection DuplicatedCode
        if (weapons['main_hand'] === null) {
            weapons['main_hand'] = weapon['name'];
        } else {
            if (weapons['off_hand'] === null) {
                weapons['off_hand'] = weapon['name'];
            } else {
                if (weapons['left_hand'] === null) {
                    weapons['left_hand'] = weapon['name'];
                } else {
                    if (weapons['right_hand'] === null) {
                        weapons['right_hand'] = weapon['name'];
                    }
                }
            }
        }
    }
    //endregion

    // Return weapons object
    //console.debug(weapons);
    return weapons;
}

// Reduce the complexity of a query for searching (and possible results)
function query_cleaner(query) {
    // Leave nulls alone
    if (query === null) {
        return null;
    }
    // If query is an array, select the first element
    if (Array.isArray(query)) {
        query = query[0];
    }

    query = query.toLowerCase();
    query = query.replace(/_/g, '');
    query = query.replace(/-/g, '');
    query = query.replace(/ /g, '');
    return query;
}

// Check if there is a synonym for the given string
function has_synonym(query) {
    query = query_cleaner(query);
    return synonyms.hasOwnProperty(query);
}

// Get the synonym for the given string
function get_synonym(query) {
    query = query_cleaner(query);
    return synonyms[query];
}

// Search for a filter in the given parsed filter file, by key
function search_filter_by(key = null, item_type = null, first_search = true) {
    // Bail on bad queries
    if (key === null && item_type === null) {
        return null;
    }
    if (key === '' || item_type === '') {
        return null;
    }

    // Simplify queries
    key = query_cleaner(key);
    item_type = query_cleaner(item_type);

    //region Key Searching
    if (key !== null) {
        // Search for the key in the Affixes
        for (let i = 0; i < filter['Affixes'].length; i++) {
            let filter_item = filter['Affixes'][i];
            // use query_cleaner on all keys
            let filter_key = query_cleaner(Object.keys(filter_item)[0]);

            if (filter_key === key) {
                //console.debug('search result (A): ', filter_item[key]);
                return filter_item[key];
            }
        }

        // Search for the key in the Uniques
        for (let i = 0; i < filter['Uniques'].length; i++) {
            let filter_item = filter['Uniques'][i];
            if (Array.isArray(filter_item['aspect'])) {
                if (query_cleaner(filter_item['aspect'][0]) === key) {
                    //console.debug('search result ([U]): ', filter_item);
                    return filter_item;
                }
            } else {
                if (query_cleaner(filter_item['aspect']) === key) {
                    //console.debug('search result (U): ', filter_item);
                    return filter_item;
                }
            }
        }
    }
    //endregion
    //region Item-Type Searching
    if (item_type !== null) {
        // Search for the item_type in the Affixes
        for (let i = 0; i < filter['Affixes'].length; i++) {
            let filter_item = filter['Affixes'][i];
            filter_item = filter_item[Object.keys(filter_item)[0]];
            let filter_item_type = query_cleaner(filter_item['itemType']);
            if (filter_item_type === item_type) {
                //console.debug('search result (I): ', filter_item);
                return filter_item;
            }
        }
    }
    //endregion

    // If key has a synonym, search for that
    if (has_synonym(key) && first_search) {
        return search_filter_by(get_synonym(key), null, false);
    }
    // If item_type has a synonym, search for that
    if (has_synonym(item_type) && first_search) {
        return search_filter_by(null, get_synonym(item_type), false);
    }

    // Return null if nothing found
    return null;
}

//endregion

////////////////////////////////////////////////////////////////////////////////////
//region Loading and Saving Filters
////////////////////////////////////////////////////////////////////////////////////

// Parse the given filter
reader.onload = readerEvent => {
    let content = readerEvent.target.result;
    try {
        // Load the filter
        // noinspection JSCheckFunctionSignatures
        filter = jsyaml.load(content);
        console.debug(filter);

        // Save the filter
        editor_data = parse_filter();
        editor_source = existing_filter;
        // Show the editor
        show_editor();
    } catch (e) {
        console.debug(content);
        console.debug(filter);
        console.error(e);
    }
}

// To convert a js-yaml-read filter into the same format as editor_layout
function parse_filter() {
    let filled_data = editor_layout;
    // Parse unique-to-slot mappings
    let unique_mapping = read_unique_slot_mapping(filter);
    let all_uniques_unslotted = unique_mapping === false;
    // Parse weapon slots
    let weapons = parse_weapons(unique_mapping);

    // Foreach over each slot in the editor layout
    for (let i = 0; i < editor_layout.length; i++) {
        let layout_item = editor_layout[i];
        let slot = layout_item.slot;

        // Skip blanks
        if (jQuery.isEmptyObject(layout_item)) {
            continue;
        }

        // If the slot is a weapon, assign the parsed weapon to it
        if (slot.includes('hand')) {
            if (weapons[slot] !== null) {
                // If array - Unique
                if (Array.isArray(weapons[slot])) {
                    layout_item['filters'] = search_filter_by(weapons[slot][0]);
                }
                // If string - Affix
                else {
                    layout_item['filters'] = search_filter_by(weapons[slot]);
                }
            }
            continue;
        }

        // If the slot is one assigned to a unique, assign the unique to it
        if (!all_uniques_unslotted) {
            if (unique_mapping.hasOwnProperty(slot)) {
                layout_item['filters'] = search_filter_by(unique_mapping[slot]);
                continue;
            }
            if (has_synonym(slot)) {
                if (unique_mapping.hasOwnProperty(get_synonym(slot))) {
                    layout_item['filters'] = search_filter_by(unique_mapping[get_synonym(
                        slot)]);
                    continue;
                }
            }
        }

        // Set the filter for the slot based solely on item type
        layout_item['filters'] = search_filter_by(null, slot);
    }

    // Add the unslotted uniques to the end of the editor layout
    // If all uniques are unslotted, add them all
    if (all_uniques_unslotted) {
        let uniques = filter['Uniques'];
        for (let i = 0; i < uniques.length; i++) {
            let unique = uniques[i];
            let layout_item = {slot: 'unique', filters: unique};
            filled_data.push(layout_item);
        }
    }
    // If some uniques are slotted, add just the unslotted ones
    else {
        let uniques = filter['Uniques'];
        for (let i = 0; i < uniques.length; i++) {
            let unique = uniques[i];
            let aspect = Array.isArray(unique['aspect']) ? unique['aspect'][0] : unique['aspect'];
            // if aspect is not one of the values in the mapping, add it to the end
            if (!Object.values(unique_mapping).includes(aspect)) {
                let layout_item = {slot: 'unique', filters: unique};
                filled_data.push(layout_item);
            }
        }
    }

    return filled_data;
}
